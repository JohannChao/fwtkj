### 定义

泛型是 JDK5 中引入的一个新特性，泛型提供了编译时类型安全监测机制，该机制允许我们在编译时检测到非法的类型数据结构。
泛型的本质就是参数化类型，也就是所操作的数据类型被指定为一个参数。

#### 常见的泛型---类型示例
```html
E - Element (在集合中使用，因为集合中存放的是元素)
T - Type（表示Java 类，包括基本的类和我们自定义的类）
K - Key（表示键，比如Map中的key）
V - Value（表示值）
? - （表示不确定的java类型）
```

泛型不接受基本数据类型，换句话说，只有引用类型才能作为泛型方法的实际参数。

### 泛型的优点

提高了Java的类型安全。在不使用泛型的情况有，有些类型转换错误，在编译期无法被检测出来。
由于使用泛型之前，我们已经明确了使用的数据是哪种类型，因此取出数据时，也不再需要对数据进行强制类型转换。

### 泛型方法

在 java 中，泛型方法可以使用在成员方法、构造方法和静态方法中。

定义泛型方法时，必须在返回值前边加一个<T>，来声明这是一个泛型方法

泛型方法的语法如下：
```html 
public <申明泛型的类型> 返回值类型参数 fun(){}; 

成员方法：public <T> T fun(T t)；
这里的 T 表示一个泛型类型，而 <T> 表示我们定义了一个类型为 T 的类型，这样的 T 类型就可以直接使用了，且<T> 需要放在方法的返回值类型之前。
即，T 在声明的时候是不知道具体的类型的，只有的使用的时候才能明确其类型，T 不是一个类，但是可以当作是一种类型来使用。

构造器方法：public <T> Father(T t) {}

注意：在编译期，我们无法知晓泛型的具体类型，只有在运行期，才会根据实际传入的值，来确定泛型类型。
参见示例： GenericsTest # listAdd
```

### 泛型类

如果一个类里面，有多个实用到泛型的方法，此时需要在每个泛型方法前面，声明一次泛型类型 <T>。

其实，我们也可以不这么做，而是可以选择在类上，直接声明一下泛型类型<T>，此时这个类下的所有非静态方法使用到这个泛型类型时，就可以不用再次声明了

泛型类语法：
```html
public class 类名< 泛型类型1,泛型类型2 ...> {}

为什么泛型类中，静态方法不能使用类定义的泛型类型呢？

因为静态方法是通过类直接调用的，而普通方法必须通过实例来调用，类在调用静态方法的时候，后面的泛型类还没有被创建，所以肯定不能这么去调用的。
所以，静态方法中使用泛型，还是老老实实这么写： public static <T> T fun(T t){}; 
```

### 通配符

通配符 ? 即占位符的意思，也就是在使用期间是无法确定其类型的，只有在将来实际使用时再指明类型，它有三种形式

1. <?> 无限定的通配符。是让泛型能够接受未知类型的数据
2. < ? extends E>有上限的通配符。能接受指定类及其子类类型的数据，E就是该泛型的上边界
3. <? super E>有下限的通配符。能接受指定类及其父类类型的数据,E就是该泛型的下边界

#### 通配符之```<?>```
上面刚刚说到了使用一个类型来表示泛型类型是必须要声明的，也即 <T> ，那是不是不申明就不能使用泛型呢？当然不是，这小节介绍的 <?> 就是为了解决这个问题的。

可以直接使用占位符 ? 来代替泛型类型，但是不能用占位符 ? 来接收参数，只能用Object老祖宗类来接收。
```html
public void wildcard(List<?> list){
    //Unexpected token
    //? e = list.get(0);
    
    Object o = list.get(0);
}
```
#### 通配符之```<? extends E>```
```html
<? extend E> 表示有上限的通配符，能接受其类型和其子类的类型 E 指上边界。
```

#### 通配符之```<? super E>```
```html
<? super E> 表示有下限的通配符。也就说能接受指定类型及其父类类型，E 即泛型类型的下边界
```

### 泛型擦除

因为泛型的信息只存在于 java 的编译阶段，编译期编译完带有 java 泛型的程序后，其生成的 class 文件中与泛型相关的信息会被擦除掉，
以此来保证程序运行的效率并不会受影响，也就说泛型类型在 jvm 中和普通类是一样的。

示例： GenericsTest # genericsErasure
