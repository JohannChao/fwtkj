### 代理模式
给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式。

#### 代理模式角色
1），Subject（抽象主题角色）：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；

2），RealSubject（真实主题角色）：真正实现业务逻辑的类；

3），Proxy（代理主题角色）：用来代理和封装真实主题；

#### 代理模式分类
1），代理模式按照职责（使用场景）来分类，至少可以分为以下几类：
1、远程代理。 2、虚拟代理。 
3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 
5、Cache代理。 6、防火墙（Firewall）代理。 
7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理等等。

2），根据字节码的创建时机，可以分为静态代理和动态代理：
* 所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和真实主题角色的关系在运行前就确定了。
* 而动态代理的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以在运行前并不存在代理类的字节码文件。

### 静态代理
#### 静态代理的实现步骤：

1），抽离出一个抽象主题接口，定义代理类和真实主题类的对外方法； 

2），生成一个实现该抽象主题接口的类，即真实主题类，真正实现业务逻辑的类；

3），生成一个代理类，该代理类实现抽象主题接口。其中的方法实现（即真实的业务逻辑处理）基本是是调用的真实主题类。
在方法实现中，添加了其他功能，诸如```before()```，```after()```日志功能等。

#### 静态代理的优缺点

##### 优点：
使用静态代理，可以在不侵入源代码的情况下，对原有的功能模块进行增强。

##### 缺点：
1），当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：
* 只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大
* 新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类

2），当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，不易维护。

### 动态代理

