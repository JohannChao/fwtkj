### 代理模式
给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式。

#### 代理模式角色
1），Subject（抽象主题角色）：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；

2），RealSubject（真实主题角色）：真正实现业务逻辑的类；

3），Proxy（代理主题角色）：用来代理和封装真实主题；

#### 代理模式分类
1），代理模式按照职责（使用场景）来分类，至少可以分为以下几类：
1、远程代理。 2、虚拟代理。 
3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 
5、Cache代理。 6、防火墙（Firewall）代理。 
7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理等等。

2），根据字节码的创建时机，可以分为静态代理和动态代理：
* 所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和真实主题角色的关系在运行前就确定了。
* 而动态代理的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以在运行前并不存在代理类的字节码文件。

### 静态代理
#### 静态代理的实现步骤：

1），抽离出一个抽象主题接口，定义代理类和真实主题类的对外方法； 

2），生成一个实现该抽象主题接口的类，即真实主题类，真正实现业务逻辑的类；

3），生成一个代理类，该代理类实现抽象主题接口。其中的方法实现（即真实的业务逻辑处理）基本是是调用的真实主题类。
在方法实现中，添加了其他功能，诸如```before()```，```after()```日志功能等。

#### 静态代理的优缺点

##### 优点：
使用静态代理，可以在不侵入源代码的情况下，对原有的功能模块进行增强。

##### 缺点：
1），当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：
* 只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大
* 新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类

2），当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，不易维护。

### 动态代理

代理类在程序运行时创建的代理方式被成为 动态代理。

在了解动态代理之前, 我们先简回顾一下 JVM 的类加载机制中的加载阶段要做的三件事情：
1. 通过一个类的全名或其它途径来获取这个类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的 Class 对象, 作为方法区中对这个类访问的入口

而我们要说的动态代理，主要就发生在第一个阶段, 这个阶段类的二进制字节流的来源可以有很多, 比如 zip 包、网络、运行时计算生成、其它文件生成 (JSP)、数据库获取。

其中运行时计算生成就是我们所说的动态代理技术，在 Proxy 类中, 就是运用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 *$Proxy 的代理类的二进制字节流。

所谓的动态代理就是想办法根据接口或者目标对象计算出代理类的字节码然后加载进 JVM 中。实际计算的情况会很复杂，我们借助一些诸如 JDK 动态代理实现、CGLIB 第三方库来完成的。

Java中常用的动态代理技术有：通过接口的 JDK 动态代理，和通过继承类的 CGLIB 动态代理。

#### JDK动态代理

在 Java 的动态代理中, 主要涉及 2 个类,java.lang.reflect.Proxy和java.lang.reflect.InvocationHandler。

我们需要一个实现 InvocationHandler 接口的中间类, 这个接口只有一个方法 invoke 方法
```java
public interface InvocationHandler {
    /**
     * 调用处理
     * @param proxy 代理类对象
     * @param methon 标识具体调用的是代理类的哪个方法
     * @param args 代理类方法的参数
     */
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
```
我们对处理类中的所有方法的调用都会变成对 invoke 方法的调用，这样我们可以在 invoke 方法中添加统一的处理逻辑（也可以根据 method 参数判断是哪个方法）。

中间类 (实现了 InvocationHandler 的类) 有一个委托类对象引用, 在 Invoke 方法中调用了委托类对象的相应方法，通过这种聚合的方式持有委托类对象引用，把外部对 invoke 的调用最终都转为对委托类对象的调用。

实际上，中间类与委托类构成了静态代理关系，在这个关系中，中间类是代理类，委托类是委托类。然后代理类与中间类也构成一个静态代理关系，在这个关系中，中间类是委托类，代理类是代理类。
也就是说，动态代理关系由两组静态代理关系组成，这就是动态代理的原理。

JDK的动态代理流程为：
1. 通过 newProxyInstance 方法获取代理类的实例（动态代理生成的代理类为 UserServiceImplProxy ```ProxyUtils.generateProxyClass(userService.getClass(),"UserServiceImplProxy");```）;
2. 对代理类的方法调用都会调用中间类 (实现了 invocationHandle 的类) 的 invoke 方法;
3. 在 invoke 方法中我们调用委托类的对应方法，然后加上自己的处理逻辑。
```java
// Proxy.newProxyInstance 源码阅读
public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
        // 检查空指针
        Objects.requireNonNull(h);
        // 用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象
        final Class<?>[] intfs = interfaces.clone();
        // 获取系统的安全接口,不为空的话需要验证是否允许访问这种关系的代理访问
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
        }

        /*
         * 生成代理类 Class,通过类加载器和接口
         */
        Class<?> cl = getProxyClass0(loader, intfs);

        /*
         * 通过构造器来创建实例
         */
        try {
            if (sm != null) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }
            //获取所有的构造器
            final Constructor<?> cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            // 构造器不是public的话需要设置可以访问
            if (!Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        cons.setAccessible(true);
                        return null;
                    }
                });
            }
            // 返回创建的代理类Class的实例对象
            return cons.newInstance(new Object[]{h});
        } catch (IllegalAccessException|InstantiationException e) {
            throw new InternalError(e.toString(), e);
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                throw new InternalError(t.toString(), t);
            }
        } catch (NoSuchMethodException e) {
            throw new InternalError(e.toString(), e);
        }
    }
```

JOK 动态代理最大的特点就是动态生成的代理类和委托类实现同一个接口。
JOK 动态代理其实内部是通过反射机制实现的，也就是已知的一个对象，在运行的时候动态调用它的方法，并且调用的时候还可以加一些自己的逻辑在里面。    

#### CGLIB动态代理