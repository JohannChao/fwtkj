### 二进制与十进制的转换

#### 1，十进制转二进制

##### 1.1，十进制整数部分
```text
整数部分采用除2倒取余法，具体做法：
用2去除十进制整数，可以得到一个商和余数；
在用2去除商，又会得到一个商和余数，
如此进行，知道商为0时为止。
然后把先的到的余数作为二进制的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。

---
以 131 举例：
被除数   除数  商  余数     对应的十进制权值     
131     2    65   1      2^0 = 1
65      2    32   1      2^1 = 2
32      2    16   0      2^2 = 4
16      2    8    0      2^3 = 8
8       2    4    0      2^4 = 16
4       2    2    0      2^5 = 32
2       2    1    0      2^6 = 64
1       2    0    1      2^7 = 128
得到 131 的二进制是 1000,0011
```
##### 1.2，十进制小数部分
```text
小数部分采用乘2取整法，具体做法：
用2乘十进制小数，可以得到积，将积中的整数部分取出；
在用2乘余下的小数部分，又得到一个积，在将积中的整数部分取出；
如此进行，直到积中的小数部分为0，此时0或1为二进制的最后一位，或者达到所要求的精度为止。
然后把取出的整数部分按顺序排列起来，先取得整数作为二进制小数的最高位有效位，后取的整数作为低位有效位。

---
以 0.84666 举例：
被乘数      乘数   积         积的整数部分    对应的十进制权值
0.84666    2     1.69332    1             2^(-1) = 0.5   
0.69332    2     1.38664    1             2^(-2) = 0.25
0.38664    2     0.77328    0             2^(-3) = 0.125
0.77328    2     1.54656    1             2^(-4) = 0.0625
0.54656    2     1.09312    1             2^(-5) = 0.03125
0.09312    2     0.18624    0             2^(-6) = 0.015625
0.18624    2     0.37248    0             2^(-7) = 0.0078125
0.37248    2     0.74496    0             2^(-8) = 0.00390625
0.74496    2     1.48992    1             2^(-9)
0.48992    2     0.97984    0             2^(-10)
0.97984    2     1.95968    1             2^(-11)
0.95968    2     1.91936    1             2^(-12)
得到 0.84666 的二进制是 1101,1000,1011...
```

#### 2，二进制转十进制
只需将每一位上的二进制数与对应的权值相乘，再把这些乘积累加起来即可。


### 浮点数的存储方式
```text
1，float与double的范围
int 和 float 同样占据四个字节的内存，但是 float 所能表示的最大值比 int 大得多，，其根本原因是浮点数在内存中是以指数的方式存储。

float ： 
1bit（符号位） -8bits（指数位）-23bits（尾数位）【float 偏移量值为 127】
float的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38。

double ：
1bit（符号位）-11bits（指数位）-52bits（尾数位）【double 偏移量值为 1023】
double的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~ +1.79E+308。

浮点数 -19.625 用float是如何存储的：
将浮点数转换成二进制：10011.101（将 19.625 整数部分采用除 2 取余，小数部分采用乘 2 取整法）；
用科学计数法表示二进制浮点数：1.0011101*2^4；
计算指数偏移后的值：127 + 4 = 131 （10000011）；
拼接综上所述，float 类型的 19.625 在内存中的值为：
1 - 10000011 - 001 1101 0000 0000 0000 0000。

  (-1)^1 * 二进制的(1.0011101) * 2^(二进制的(10000011)-127)
= -19.625



2，float与double的精度
float和double的精度是由尾数的位数来决定的，尾数越多能表示的小数点后面有效数字就越多，因此精度就越高。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。

float：2^23 = 8388608，一共七位，这意味着最多能有 7 位有效数字，但绝对能保证的为 6 位，也即float的精度为 6~7 位有效数字；

double：2^52 = 4503599627370496，一共 16 位，同理，double的精度为 15~16 位。
```
[一直迷糊的浮点数](https://zhuanlan.zhihu.com/p/75581822)

[计算机是如何保存小数的？](https://www.zhihu.com/question/315448681/answer/1543955876)

### 取模运算与取余运算
对于整型数a，b来说，取模运算或者求余运算的方法都是：
1. 求整数商： c = [a/b];
2. 计算模或者余数： r = a - c*b.

求模运算和求余运算在第一步不同: 取余运算在取c的值时，向0 方向舍入(fix()函数)；而取模运算在计算c的值时，向负无穷方向舍入(floor()函数)。
```text
1，示例一，ab均为正数
a = 9, b = 4
取模运算第一步（商值向着负无穷方向舍入）：
  c = a/b = 2
取余运算第一步（商值向着 0 的方向舍入）:
  c = a/b = 2
此时商相同，取模和取余结果相同，均为 r = a - c*b = 1。

2，示例二，ab均为负数
a = -9, b = -4
取模运算第一步（商值向着负无穷方向舍入）：
  c = a/b = 2
取余运算第一步（商值向着 0 的方向舍入）:
  c = a/b = 2
此时商相同，取模和取余结果相同，均为 r = a - c*b = -1。

3，示例三，a为正数，b为负数
a = 9, b = -4
取模运算第一步（商值向着负无穷方向舍入）：
  c = a/b = -3
取余运算第一步（商值向着 0 的方向舍入）:
  c = a/b = -2
此时商不同，取模结果为 r = -3，取余结果为 r = 1。

4，示例四，a为负数，b为正数
a = -9, b = 4
取模运算第一步（商值向着负无穷方向舍入）：
  c = a/b = -3
取余运算第一步（商值向着 0 的方向舍入）:
  c = a/b = -2
此时商不同，取模结果为 r = 3，取余结果为 r = -1。

结论：
● 当被除数和除数的符号相同时，取模和取余运算结果相同；当符号不同时，结果也不同。
● 当被除数与除数的符号相同时，取模结果的符号被除数相同；当符号不同时，取模结果的符号与被除数相反。
```

### 原码，反码，补码

#### 1，模
了解原码，反码，补码之前，先介绍一下模，有助于后续理解。

##### 1.1，钟表举例
以钟表举例，当前时针指向 8 点，如果要让时针指向 3 点，可以有以下两种方式：
* 1）逆时针拨动 5 大格（7，6，5，4，3）；
* 2）顺时针拨动 7 大格（9，10，11，0，1，2，3）

钟表的格数极限是 12 格，此时将这个极限称为“模”。两个相加等于 12 的数互为补数，即 5 和 7 互为补数。

时钟从 8 点拨到 3 点，由以下两种方式实现 8 - 5 = 3，或者 8 + 7 = 15 = 3(+模) 来实现。

所以，在时钟上做加减法，可以将 “M-N” 这类的减法操作，变为 “M + N的补数” 这类的加法操作。

M-N = M+(-N) = M+N的补数，由此可知：【负数的表达式等于它绝对值的补数】。

##### 1.2，二进制举例
以 8 位二进制数举例，在不考虑首位是符号位的情况下，其范围是 0 ~ 255 ，即一共有 256 个数。256 是这个 8 位二进制数所能表示的数字个数的极限，此时“模”是 256。

【此处还是忘掉第一位是符号位，即 1表示负，0表示正】
将 0 ~ 255 区间的数对半分开，0 ~ 127 表示正数，128 ~ 255 表示负数，即 -1 ~ -128。

-128 的值如何表示？在钟表中我们得出结论【负数的表达式等于它绝对值的补数】，此时 -128 的绝对值的补数是 256 - |-128| = 128，其二进制数是 1000,0000。

-1 的值如何表示？ 256 - |-1| = 255，其二进制数是 1111,1111。

#### 2，原码
原码，最简单的机器数表示法，用最高位表示符号位，其他位存放该数的二进制的绝对值。

* 【+1】原 = 0000,0001
* 【-1】原 = 1000,0001

8 位二进制数的原码取值范围 【1111,1111 ~ 0111,1111】，即 -127 ~ 127，其中 【0000,0000】是 +0，【1000,0000】是 -0。 

>原码计算减法：
>1 - 1 = 1 + (-1) = 0000,0001【原】 + 1000,0001【原】 = 1000,0010【原】。对应的十进制是 -2 【错】

#### 3，反码

反码，正数的反码还是等于原码；负数的反码就是它的原码除符号位外，按位取反。

* 【+1】 = 【0000,0001】原 = 【0000,0001】反
* 【-1】 = 【1000,0001】原 = 【1111,1110】反

>反码计算减法：
>1 - 1 = 1 + (-1) = 0000,0001【反】 + 1111,1110【反】 = 1111,1111【反】 = 1000,0000【原】。对应的十进制是 -0 ，虽然结果是对的，但无法避免 0 的正负问题。

#### 4，补码
补码，正数的补码等于它的原码；负数的补码等于反码+1。

* 【+1】 = 【0000,0001】原 = 【0000,0001】反 = 【0000,0001】补
* 【-1】 = 【1000,0001】原 = 【1111,1110】反 = 【1111,1111】补

> 1.2中，提到 -1 是用 1111,1111 来表示，而在计算机中，负数也确实是采用补码的形式储存的。
> 1.2中，提到 -128 是用 1000,0000 来表示，1000,0000正是 -128 的补码，而-128并没有原码和反码表示。

8 位二进制数的原码取值范围 【1000,0000 ~ 0111,1111】，即 -128 ~ 127。

>补码计算减法：
>1 - 1 = 1 + (-1) = 0000,0001【补】 + 1111,1111【补】 = 1,0000,0000【补】 
> 1,0000,0000溢出，最高位的1，计算机会把它放入psw寄存器进位位中。
>所以最终的计算结果是 0000,0000【补】，原码也是 0000,0000，对应的十进制是 0。
