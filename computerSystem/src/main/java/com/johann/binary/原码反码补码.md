### 原码，反码，补码

#### 1，模
了解原码，反码，补码之前，先介绍一下模，有助于后续理解。

##### 1.1，钟表举例
以钟表举例，当前时针指向 8 点，如果要让时针指向 3 点，可以有以下两种方式：
* 1）逆时针拨动 5 大格（7，6，5，4，3）；
* 2）顺时针拨动 7 大格（9，10，11，0，1，2，3）

钟表的格数极限是 12 格，此时将这个极限称为“模”。两个相加等于 12 的数互为补数，即 5 和 7 互为补数。

时钟从 8 点拨到 3 点，由以下两种方式实现 8 - 5 = 3，或者 8 + 7 = 15 = 3(+模) 来实现。

所以，在时钟上做加减法，可以将 “M-N” 这类的减法操作，变为 “M + N的补数” 这类的加法操作。

M-N = M+(-N) = M+N的补数，由此可知：【负数的表达式等于它绝对值的补数】。

##### 1.2，二进制举例
以 8 位二进制数举例，在不考虑首位是符号位的情况下，其范围是 0 ~ 255 ，即一共有 256 个数。256 是这个 8 位二进制数所能表示的数字个数的极限，此时“模”是 256。

【此处还是忘掉第一位是符号位，即 1表示负，0表示正】
将 0 ~ 255 区间的数对半分开，0 ~ 127 表示正数，128 ~ 255 表示负数，即 -1 ~ -128。

-128 的值如何表示？在钟表中我们得出结论【负数的表达式等于它绝对值的补数】，此时 -128 的绝对值的补数是 256 - |-128| = 128，其二进制数是 1000,0000。

-1 的值如何表示？ 256 - |-1| = 255，其二进制数是 1111,1111。

#### 2，原码
原码，最简单的机器数表示法，用最高位表示符号位，其他位存放该数的二进制的绝对值。

* 【+1】原 = 0000,0001
* 【-1】原 = 1000,0001

8 位二进制数的原码取值范围 【1111,1111 ~ 0111,1111】，即 -127 ~ 127，其中 【0000,0000】是 +0，【1000,0000】是 -0。 

>原码计算减法：
>1 - 1 = 1 + (-1) = 0000,0001【原】 + 1000,0001【原】 = 1000,0010【原】。对应的十进制是 -2 【错】

#### 3，反码

反码，正数的反码还是等于原码；负数的反码就是它的原码除符号位外，按位取反。

* 【+1】 = 【0000,0001】原 = 【0000,0001】反
* 【-1】 = 【1000,0001】原 = 【1111,1110】反

>反码计算减法：
>1 - 1 = 1 + (-1) = 0000,0001【反】 + 1111,1110【反】 = 1111,1111【反】 = 1000,0000【原】。对应的十进制是 -0 ，虽然结果是对的，但无法避免 0 的正负问题。

#### 4，补码
补码，正数的补码等于它的原码；负数的补码等于反码+1。

* 【+1】 = 【0000,0001】原 = 【0000,0001】反 = 【0000,0001】补
* 【-1】 = 【1000,0001】原 = 【1111,1110】反 = 【1111,1111】补

> 1.2中，提到 -1 是用 1111,1111 来表示，而在计算机中，负数也确实是采用补码的形式储存的。
> 1.2中，提到 -128 是用 1000,0000 来表示，1000,0000正是 -128 的补码，而-128并没有原码和反码表示。

8 位二进制数的原码取值范围 【1000,0000 ~ 0111,1111】，即 -128 ~ 127。

>补码计算减法：
>1 - 1 = 1 + (-1) = 0000,0001【补】 + 1111,1111【补】 = 1,0000,0000【补】 
> 1,0000,0000溢出，最高位的1，计算机会把它放入psw寄存器进位位中。
>所以最终的计算结果是 0000,0000【补】，原码也是 0000,0000，对应的十进制是 0。
