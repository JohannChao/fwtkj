
### ISO/OSI七层模型和TCP/IP四层模型

网络分层的主要是采取分治策略，使得复杂问题简单化，网络模块组件化。每一层都有自己的职责，每一层对上一层提供服务，这样实现了职责单一，进而提高了组件的复用性。
在网络标准化过程中，国际标准化组织（ISO）把计算机网络分为 7 层，叫做[开放系统互联模型(OSI)](pic/OSI参考模型.png)。
但是，我们在实践中发现 TCP/IP 四层模型更为合理。虽然我们实际过程中都没有按OSI分为七层，但是OSI对我们实践过程分层有着指导性的意义。

#### 二者差异
从[ISO_OSI七层模型和TCP_IP四层模型](pic/ISO_OSI七层模型和TCP_IP四层模型.png)图中可以看到二者差异部分如下：
* ISO/OSI 模型是理论分层模型，TCP/IP 模型是我们实践中使用的分层模型。

* TCP/IP 四层模型没有表示层和会话层。那么，TCP/IP 参考模型不需要表示层和会话层吗？答案是：“如果需要这两层，就由应用程序员来实现”。经过这么多年发展来看，需要表示层和会话层的场景并不多。

* TCP/IP 模型好像没有链路层，其实在网络协议实现过程中，链路层包含了网卡驱动部分和物理介质部分，所以通常把二者统一叫做链路层。

#### 各层功能解释
* 应用层（Application Layer）是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。
由应用程序自定义协议格式。不同的领域，对网络应用程序的需求是不同的，必须给用户自定义协议格式的权利。(典型协议：http、https、ftp、ssh、smtp、pop3、telnet)

* 表示层（Presentation）是OSI模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。
主要是定义数据格式。比如，加密和解密、压缩和解压缩。在 TCP/IP 模型中，表示层协议包含在应用层里。比如 SSL/TLS 协议。

* 会话层（Session Layer）是OSI模型的第五层，是用户应用程序和网络之间的接口。
用于在两个通信实体之间建立会话、维护会话、终止会话。设置检查点，当系统出现崩溃拉起后，通过寻找检查点恢复运行。在 TCP/IP 模型中，会话层协议包含在应用层里。比如 NetBIOS 协议。

* 传输层（Transport Layer），OSI下三层的主要任务是数据通信，上三层的任务是数据处理。而传输层（Transport Layer）是OSI模型的第四层。因此该层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。
传输层的主要任务：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。其作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。
在 TCP/IP 模型中最重要的两个传输协议就是 TCP 和 UDP，前者是可靠的、面向字节流的传输；后者是不可靠的、面向数据报(Datagram)的传输。
> 通常把 TCP 传输的报文称作报文段（Segment）。把 UDP 传输的报文称作消息（Message）或者是数据报（Datagram）。   

* 网络层（Network Layer）是将 IP 分组从源端路由到目的端。网络层是为传输层服务的，在发送端的网络层收到传输层的数据后，必要时会对数据切片以后再封包发送。
实现网络层协议是路由器的主要职责，是构建通信子网的基础。比如， RIP、OSPF 就是最基础的路由协议。路由器是通过 IP 分组的目的 IP 地址查找本地路由表，寻找转发的目标端。
所以路由器的主要工作就是路由选择和转发，IP 分组是逐跳（hop）转发的。
> 通常把网络层传输的报文叫做 IP 分组（Packet）。

* 链路层（Data Link Layer）是为网络层服务的。发送的时候将网络层的数据分片，封装成帧（Frame），然后顺序发送。与网络层实现端到端的路由不同，链路层是实现节点之间的数据传送。
常用的链路层协议就是以太网（Ethernet）协议。
> 通常把链路层传输的报文叫做帧（Frame）。

* 物理层（Physical Layer）是描述如何在物理介质中传输 bit 位。比如，用多少伏电压表示“1”，用多少伏电压表示“0”等。

我们把分层的网络参考模型叫做协议栈(Protocol Stack)。目前所有网络协议栈的实现都采用了 TCP/IP 参考模型。协议栈的实现是包含在操作系统内核中的，比如 Windows 和 Unix-like 系统。

### TCP/IP协议族
[TCP_IP 协议族](pic/TCP_IP协议族.png)
##### 1，应用层
* HTTP（Hypertext Transfer Protocol）超文本传输协议，只要你浏览页面就会用到此协议。

* SMTP（Simple Mail Transfer Protocol）简单邮件传输协议，用于电子邮件传输。

* FTP（File Transfer Protocol）文件传输协议，用于文件的上传和下载。现在 FTP 貌似用的不多了，早期主要是在公司内部、大学等研究机构用的比较多。

* RTMP（Real-Time Messaging Protocol）实时消息协议，用于实时流媒体传输，主要用在音视频直播领域，属于 Adobe 公司出品。不过，从 2020 年开始，Adobe 就不再支持 RTMP 协议了。

* SNMP（Simple Network Management Protocol）简单网络管理协议，用于电信网络设备的管理。比如，监控设备告警，对设备进行业务配置等。主要是在思科、华为等电信网络设备上用的比较多。

其实，应用层除了以上诸多知名协议外，也可以是用户自定义协议。

##### 2，传输层
* TCP（Transmission Control Protocol）传输控制协议，是面向连接的、可靠的、面向字节流的传输协议。TCP 应用非常广泛，是端到端传输的基石。

* UDP（User Datagram Protocol）用户数据报协议，是无连接的、不可靠的、面向消息的传输协议。UDP 实时性好，效率高，在音视频传输中有着广泛的应用。

##### 3，网络层
* IPv4 （Internet Protocol version 4）此协议主要是用于 IP 分组的路由转发，是路由器主要实现的协议。我们经常说的 IP 地址是指 IPv4 地址，用 32 bit 来表示。

* IPv6 （Internet Protocol version 6）此协议工作原理类似 IPv4。之所以设计 IPv6 的目的是因为上世纪 90 年代中期，因特网爆炸式的增长，32 位 IPv4 地址不够用了，为此才设计了 128 位的 IPv6 地址。

* ICMP（Internet Control Message Protocol）因特网控制消息协议，主要是用于显示网络错误。比如，我们用 ping 的时候，有时会显示“网络不可达”的错误。

* ICMPv6 （Internet Control Message Protocol Version 6）整合了 ICMP 协议，针对 IPv6 开发的协议。

* IGMP（Internet Group Management Protocol）因特网组管理协议，主要是用于 IP Multicast 的场景，比如观看 IP 电视节目。

##### 4，链路层
* ARP（Address Resolution Protocol）地址解析协议，主要是用于生成 IP 地址和物理地址(比如以太网 MAC 地址)的映射表，用于数据包的快速转发。

* RARP（Reverse Address Resolution Protocol）反向地址解析协议，主要是用于生成物理地址和 IP 地址的映射。


### IP 地址
[网络编程_IP地址详解](网络编程_IP地址详解.md)


### 字节序

> CPU地址空间是从低地址到高地址增长的。

　　我们知道 CPU 访问内存是通过地址总线完成的，一块连续的内存空间是经过编址的，每一个地址编号对应 1 字节长度的内存空间，地址空间是从低地址到高地址增长的。
如果要在内存中存储 0xAABBCCDD(1010 1010 1011 1011 1100 1100 1101 1101) 这样一个长度为 4 字节的十六进制整数，需要 4 字节的内存空间。

内存空间示意图：
```text
   100  101  102  103  -------> 内存地址由低到高增长的方向
   +----+----+----+----+
   |    |    |    |    |
   +----+----+----+----+
```
　　那么 0xAA 是存储在地址编号为 100 的空间呢？还是存储在地址编号为 103 的空间呢？这就是本节要讨论的字节序的问题。

　　字节序有大端序（Big-Endian）和小端序（Little-Endian）之分。对于前面提到的十六进制整数 0xAABBCCDD 来说，
如果按照大端序在内存中存储，那么从低地址到高地址的存储顺序依次是 0xAA、0xBB、0xCC、0xDD；
如果按照小端序在内存中存储，那么从低地址到高地址的存储顺序依次是 0xDD、0xCC、0xBB、0xAA。

#### 计算机的字节序

　　在操作系统课程中，我们学过现代操作系统的内存管理机制是虚拟内存管理机制，对于 32 位系统来说，每一个进程都有 4G（2^32）字节长度的虚拟地址空间，也叫线性地址空间。
```text
虚拟地址空间示例图

    0x90000001      00
                    
    0x90000002      00
    
    0x90000003      FF
    
    0x90000004      EE
    
    0x90000005      FF    
    
    0x90000006      CC
    
    0x90000007      DD
    
    0x90000008      34
    
    0x90000009      FF
    
    0x9000000A      22
```
　　虚拟地址空间示例图中用内存地址 0x90000001 ~ 0x9000000A 表示了 10 字节的内存地址空间，每一个地址代表 1 字节的内存。当一个多字节整数存储在内存中时，会涉及到字节序的问题。

　　首先，需要搞清楚两个术语，最高有效位和最低有效位。我们知道，人类习惯的阅读顺序是从左到右，对于一个多位数字来说，经常把它的最左边叫做高位，把它的最右边叫做低位。
而在计算机中，对于一个多位数字的描述，也有类似的专业术语，把左边的最高位叫做最高有效位（MSB，most significant bit）；把右边最低位叫做最低有效位（LSB，least significant bit）。

　　如果按照小端序来存储，0xAABBCCDD 在内存中从低地址到高地址的存储顺序是 0xDD、0xCC、0xBB、0xAA，存储顺序和人类习惯的阅读顺序是相反的。
```text
小端序：最低有效位存放在低地址，最高有效位存放在高地址

最高有效位    最低有效位
————————————————>
0xAA  0xBB  0xCC  0xDD


低地址             高地址
————————————————————————>
0x90000000  0x90000001  0x90000002  0x90000003

0xDD        0xCC        0xBB        0xAA
```

　　如果按照大端序来存储，0xAABBCCDD 在内存中从低地址到高地址的存储顺序是 0xAA、0xBB、0xCC、0xDD，存储顺序和人类习惯的阅读顺序是相同的。
```text
大端序：最高有效位存放在低地址，最低有效位存放在高地址

最高有效位    最低有效位
————————————————>
0xAA  0xBB  0xCC  0xDD


低地址             高地址
————————————————————————>
0x90000000  0x90000001  0x90000002  0x90000003

0xAA        0xBB        0xCC        0xDD
```

> Intel 架构、ARM 架构是小端序。JAVA 存储多字节整数，采用大端序。

　　大小端序是由于 CPU 架构的不同导致的，在历史上 IBM System/360 、Motorola 6800 / 6801、SPARC 是大端序；Intel 架构、ARM 架构是小端序。另外，JAVA 存储多字节整数，也是采用大端序。

#### 字节序获取

[字节序获取_示例代码](netWorkBasic/ByteOrderTest.java)

1. 通过``` ByteOrder.nativeOrder() ```可以获取到系统本身的字节序

2. JAVA 中没有指针的概念，所以不能通过取地址的方式直接打印内存的值。需要借助 JAVA 的 ByteBuffer，将 int 型数值存储到 ByteBuffer 中，
然后将 ByteBuffer 转换成字节数组，通过打印数组的方式来达到我们的目的。

3. Java多字节Buffer的字节序规则

* 如果多字节 Buffer 是通过数组（Array）创建的，那么它的字节序和底层系统的字节序一致。

* 如果多字节 Buffer 是通过 ByteBuffer 创建的，那么它的字节序和 ByteBuffer 的字节序一致。    


#### 网络字节序

　　前面讨论的都是 CPU、Java 虚拟机的字节序，通常叫做主机（host）字节序。在网络编程中，字节流在网络中传输是遵循大端序的，也叫网络字节序。

　　由于 Java 虚拟机的字节序和网络字节序是一致的，对于 Java 程序员来说，通常不太关心字节序的问题。然而，当 Java 程序和 C 程序进行通信的时候，需要关心字节序的问题。

### InetAddress类介绍
　　在 Java 平台中，java.net.InetAddress 类实现了完整的 IP 地址和域名之间的相互解析机制。

[InetAddress_示例代码](netWorkBasic/InetAddressTest.java)

#### getByName 方法 
　　InetAddress 提供了两个公有静态方法 getByName 和 getAllByName 来构造 InetAddress 实例
```text
// 创建单个 InetAddress 实例
public static InetAddress getByName(String host) throws UnknownHostException
// 创建多个 InetAddress 实例
public static InetAddress[] getAllByName(String host) throws UnknownHostException
```
　　这两个方法都会连接域名解析服务器进行域名解析，具体工作原理如下：

* 首先会检查传入参数 host，也就是域名。如果传入参数为 null，那么会返回以 loopback 地址构造的 InetAddress 结构。
* 如果输入参数 host 是一个 IP 地址，那么根据 IP 地址是 IPv4 还是 IPv6，分别构造 Inet4Address 或 Inet6Address 结构，并且返回。
* 查询本地 Cache，如果本地 Cache 中已经存在 host 相应的地址，则直接返回。
* 如果本地 Cache 查询失败，则遍历本地注册的 name services。如果有定制的 name services 注册，那么会调用此定制的 name services。如果没有定制的 name services，
那么会调用 default name services，最终会调用系统的 getaddrinfo 函数。getaddrinfo 是一个 POSIX 标准函数，一般系统都会实现。

#### getByAddress 方法
如果你有明确的 IP 地址，并不需要进行域名解析，可以调用 InetAddress 提供的另一组工厂方法 getByAddress 来构造实例
```text
public static InetAddress getByAddress(byte[] addr) throws UnknownHostException

public static InetAddress getByAddress(String host, byte[] addr) throws UnknownHostException
```
这是两个重载的 public static 方法，功能都类似：

* 第一个重载的 getByAddress 方法提供一个参数，即用 byte [] 类型的数组表示的 IP 地址。
* 第二个重载的 getByAddress 方法提供两个参数，用 String 类型表示的域名（host），和用 byte [] 类型的数组表示的 IP 地址。
* 二者都不进行域名解析，只是根据输入参数构造 InetAddress 实例。
* 接收 host 输入参数的 getByAddress 方法不保证域名和 IP 地址的对应关系，也不保证域名是否可以访问。

#### InetAddress 的 Cache 策略
由于域名解析需要客户端和域名服务器经过很多次交互，一般都比较耗费时间，所以 InetAddress 提供了 Cache 机制。
这样，当客户程序调用 getByName 解析域名的时候，首先是从 Cache 中查找，这样可以极大提高域名解析的效率。

域名绑定的 IP 地址可能会发生变化，所以 Cache 中存储的 IP 地址也是有生命周期的。Java 提供了两个全局参数可以用来配置 Cache 的有效时间。

* networkaddress.cache.ttl
成功解析的域名在 Cache 中的存活时间。

* networkaddress.cache.negative.ttl
解析失败的域名在 Cache 中的存活时间。

##### 修改 JVM DNS 缓存的方式
> 0 从不缓存; -1 永远缓存; 其他int值 缓存存活时间(单位：秒)

1. JVM启动参数里面设置 -Dsun.net.inetaddr.ttl= -1
2. 修改配置文件 ${JAVA_HOME}/jre/lib/security/java.security 相应的参数 networkaddress.cache.ttl= -1
3. 代码里直接设置：java.security.Security.setProperty(”networkaddress.cache.ttl” , "-1")

### 创建Java TCP Socket
TCP 的英文全称是 Transmission Control Protocol，翻译成中文叫做传输控制协议，它是 TCP/IP 协议族中非常重要的一个传输层协议。
TCP 是一个面向连接的、面向字节流的、可靠的传输层协议，有丢包重传机制、有流控机制、有拥塞控制机制。TCP 保证数据包的顺序，并且对重复包进行过滤。
相比不可靠传输协议 UDP，TCP 完全是相反的。

对于可靠性要求很高的应用场景来说，选择可靠 TCP 作为传输层协议肯定是正确的。例如，著名的 HTTP 协议和 FTP 协议都是采用 TCP 进行传输。
当然 TCP 为了保证传输的可靠性，引入了非常复杂的保障机制，比如：TCP 连接建立时的三次握手和连接关闭时的四次挥手机制，滑动窗口机制，发送流控机制，慢启动和拥塞避免机制等。
当然，操作系统的网络协议栈已经实现了这些复杂的机制，

[TCP客户端与服务器](pic/TCP客户端与服务器.png)

[TCP协议连接过程](TCP协议连接过程.md)

[TCP Socket示例](javaNetwork/tcpSocket)

TCP 是面向字节流的协议，TCP 传输数据的时候并不保证消息边界，消息边界需要程序员设计应用层协议来保证。将字节流解析成自定义的协议格式，需要借助 java.io.* 中提供的工具类。
一般情况下，java.io.DataInputStream 、java.io.DataOutputStream 和 java.io.BufferedInputStream、java.io.BufferedOutputStream 四个类就足以满足你的需求了。
DataInputStream 和 DataOutputStream 类主要是用以读写 java 相关的数据类型，BufferedInputStream 和 BufferedOutputStream 解决缓冲读写的问题，目的是提高读写效率。

#### ServerSocket 中 BACKLOG 是什么？
创建 ServerSocket 的时候，可以设置 BACKLOG 大小，这个字段用于设置待连接队列的大小

结合TCP三次握手来解释就是：

* 这个队列存放的是 向服务器发送【SYN报文】，但是服务器还没来得及发送【SYN，ACK报文】的连接。
* 客户端每新建一个 socket连接，向服务器发送了【SYN报文】，这个队列就会增加 1。服务器ServerSocket accept，即发送 【SYN,ACK报文】后，就会从这个队列中取出一个连接。
* 超过 BACKLOG 上限的客户端连接，将会统统被 服务器ServerSocket 拒绝掉，客户端报异常 ：java.net.ConnectException: Connection refused: connect


### Java UDP Socket
UDP 的英文全称是：User Datagram Protocol，翻译成中文叫用户数据报协议，它是 TCP/IP 协议族中一个非常重要的传输层协议。
UDP 是一个无连接的、不可靠的传输层协议，没有丢包重传机制、没有流控机制、没有拥塞控制机制。UDP 不保证数据包的顺序，UDP 传输经常出现乱序，UDP 不对重复包进行过滤。

既然 UDP 这么多缺点，我们还有学习的必要吗？其实不然，正是因为 UDP 没有提供复杂的各种保障机制，才使得它具有实时、高效的传输特性。那么 UDP 到底有哪些优势呢？

* 第一，UDP 是面向消息的传输协议，保证数据包的边界，不需要进行消息解析，处理逻辑非常简单。
* 第二，UDP 具有实时、高效的传输特性。
* 第三，协议栈没有对 UDP 进行过多的干预，这给应用层带来了很多便利，应用程序可以根据自己的需要对传输进行控制。比如，自己实现优先级控制、流量控制、可靠性机制等。当然还有其他一些优势，我就不再一一列举。

UDP 在音视频会议、VOIP、音视频实时通信等行业有着广泛的应用。

[UDP客户端与服务器](pic/UDP客户端与服务器.png)

[UDP Socket示例](javaNetwork/udpSocket)


### 多线程TCP服务器
采用单线程模型、阻塞式模型实现的TCP服务器，java.net.ServerSocket 的 accept 方法会阻塞线程，java.net.Socket 的 recv 和 send 方法也会阻塞线程，
因此，在同一时刻，服务器只能和一个客户端通信。

要想服务器同时和多个客户端进行通信：
* 要么采用非阻塞式 Socket 编程，通过 I/O 多路复用机制 实现此目的；
* 要么采用多线程编程模型。当然，在非阻塞式 Socket 编程模型下，往往也采用多线程编程。

以下示例，主要介绍阻塞式 Socket 编程中常用的两种线程模型：
##### 1，[多线程模型](javaNetwork/tcpSocket/multiThreading)
[多线程模型结构](pic/多线程模型结构.png)

从图中可以看出，每线程模型的程序结构如下：
* 创建一个监听线程，通常会采用 Java 主线程作为监听线程。
* 创建一个 java.net.ServerSocket 实例，调用它的 accept 方法等待客户端的连接。
* 当有新的客户端和服务器建立连接，accept 方法会返回，创建一个新的线程和客户端通信。此时监听线程返回，继续调用 accept 方法，等待新的客户端连接。
* 在新线程中调用 java.net.Socket 的 recv 和 send 方法和客户端进行数据收发。
* 当数据收发完成后，调用 java.net.Socket 的 close 方法关闭连接，同时线程退出。

##### 2，[线程池模型](javaNetwork/tcpSocket/threadPool)
[线程池模型结构](pic/线程池模型结构.png)

从图中可以看出，线程池模型的程序结构如下：

* 创建一个监听线程，通常会采用 Java 主线程作为监听线程。
* 创建一个 java.net.ServerSocket 实例，调用它的 accept 方法等待客户端的连接。
* 服务器预先创建一组线程，叫做线程池。线程池中的线程，在服务运行过程中，一直运行，不会退出。
* 当有新的客户端和服务器建立连接，accept 方法会返回 java.net.Socket 对象，表示新的连接。服务器一般会创建一个处理 java.net.Socket 逻辑的任务，
并且将此任务投递给线程池去处理。然后，监听线程返回，继续调用 accept 方法，等待新的客户端连接。
* 线程池调度空闲的线程去处理任务。
* 在新任务中调用 java.net.Socket 的 recv 和 send 方法和客户端进行数据收发。
* 当数据收发完成后，调用 java.net.Socket 的 close 方法关闭连接，任务完成。
* 线程重新回归线程池，等待调度。

### Java Socket选项
下面，我们对 Socket 编程中常用的 Socket 选项重点介绍。

##### 1,SO_REUSEADDR
TCP 连接关闭过程中，主动关闭的一方会处于 TIME_WAIT 状态，要等待 2MSL 时间。而服务器在工作过程中有可能由于配置的改变而要重启，
或者是由于程序异常奔溃要重新启动。在这种情况下，如果服务器监听的 Socket 处于 TIME_WAIT 状态，那么调用 bind 方法绑定 Socket 就会失败。
如果要等待 2MSL 时间，对于服务器来说是难以接受的。要想解决此问题，需要给监听 Socket 设置 SO_REUSEADDR 选项。

Java 的 java.net.ServerSocket 类提供了 setReuseAddress 方法，可以用以设置 SO_REUSEADDR 选项

##### 2,SO_KEEPALIVE
SO_KEEPALIVE 是协议栈提供的一种连接保活机制，一般是用在 TCP 协议中。主要目的是当通信双方长时间没有数据交互，
然而 Socket还没有被关闭，协议栈会向对方发送一个 Heartbeat 消息期望对方回复一个 ACK，如果对方能回复说明连接是正常的，
如果对方不能回复，尝试几次以后就会关闭连接。系统保活的时间一般是 2 小时。

Java 的 java.net.Socket 类提供了 setKeepAlive 方法，可以用以设置 SO_KEEPALIVE 选项

##### 3,SO_LINGER
SO_LINGER 是用来设置“连接关闭以后，未发送完的数据包还可以在协议栈逗留的时间”。
java.net.Socket 提供了 setSoLinger 方法可以设置 SO_LINGER 选项。原型如下：
```text
public void setSoLinger(boolean on, int linger) throws SocketException

注：参数 linger 的单位是秒。
```
* 如果设置 on 为 false，则该选项的值被忽略，协议栈会采用默认行为。
close 调用会立即返回给调用者，协议栈会尽可能将 Socket 发送缓冲区未发送的数据发送完成。
* 如果设置 on 为 true，但是 linger 为 0，当你调用了close()方法以后，协议栈将丢弃保留在 Socket 发送缓冲区中未发送完的数据，然后向对方发送一个 RST。
这样连接很快会被关闭，不会进入 TIME_WAIT 状态，这也是一个避免“由于大量 TIME_WAIT 状态的 Socket 导致连接失败“的解决办法。
* 如果设置 on 为 true ，但是 linger 的取值大于 0，当你调用了 close() 方法以后，如果 Socket 发送缓冲区还有未发送完的数据，
那么系统会等待一个指定的时间，close() 才返回。注意，这种情况下 close() 方法返回，并不能保证 Socket 发送缓冲区中未发送的数据被成功发送完。

##### 4,SO_RCVBUF
SO_RCVBUF 很好理解，用于设置 Socket 的接收缓冲区大小。TCP 一般不需要设置，UDP 可能需要设置。
java.net.Socket 类提供了 setReceiveBufferSize 方法可以设置接收缓冲区的大小。

##### 5,SO_SNDBUF
SO_SNDBUF 也很好理解，用于设置 Socket 的发送缓冲区大小。一般不需要设置，采用系统默认大小即可。
java.net.Socket 类提供了 setSendBufferSize 方法可以设置发送缓冲区的大小。

##### 6,SO_OOBINLINE
SO_OOBINLINE 用于设置将“带外数据”作为普通数据流来处理。
java.net.Socket 类提供了 setOOBInline 方法可以设置 SO_OOBINLINE 选项。

##### 7,TCP_NODELAY
TCP_NODELAY 用于关闭 Nagle 算法，一般是用在实时性要求比较高的场景。
java.net.Socket 提供了 setTcpNoDelay 方法用于设置 TCP_NODELAY 选项。

##### 8,总结
文中列出了常用 Socket 选项的应用场景。
* SO_REUSEADDR 是服务器必须要设置的一个选项，也只有服务器才需要此功能。
* TCP_NODELAY 是在开发实时性要求很高的程序时，必须要设置的，比如音视频通信系统。
* SO_LINGER 是在服务器端解决“由于 TIME_WAIT 过多，导致连接失败的问题”时的一个常用方法。

其他选项，可以根据需要选择是否开启。


### 参考
[网络编程入门教程](https://www.imooc.com/wiki/socketlesson/nwposiisotcpip.html)
