### 图的定义

　　我们知道，前面讨论的数据结构都有一个框架，而这个框架是由相应的算法实现的，
比如二叉树搜索树，左子树上所有结点的值均小于它的根结点的值，右子树所有结点的值均大于它的根节点的值，类似这种形状使得它容易搜索数据和插入数据，树的边表示了从一个节点到另一个节点的快捷方式。

　　而图通常有个固定的形状，这是由物理或抽象的问题所决定的。比如图中节点表示城市，而边可能表示城市间的班机航线。如下图是美国加利福利亚简化的高速公路网：

[road_graph.png]

#### 1) 邻接
　　如果两个顶点被同一条边连接，就称这两个顶点是邻接的，如上图 I 和 G 就是邻接的，而 I 和 F 就不是。有时候也将和某个指定顶点邻接的顶点叫做它的邻居，比如顶点 G 的邻居是 I、H、F。

#### 2) 路径
　　路径是边的序列，比如从顶点B到顶点J的路径为 BAEJ，当然还有别的路径 BCDJ，BACDJ等等。

#### 3) 连通图和非连通图
　　如果至少有一条路径可以连接起所有的顶点，那么这个图称作连通的；如果假如存在从某个顶点不能到达另外一个顶点，则称为非联通的。

[connected_graph.png]

#### 4) 有向图和无向图
　　如果图中的边没有方向，可以从任意一边到达另一边，则称为无向图；比如双向高速公路，A城市到B城市可以开车从A驶向B，也可以开车从B城市驶向A城市。但是如果只能从A城市驶向B城市的图，那么则称为有向图。

#### 5) 有权图和无权图
　　图中的边被赋予一个权值，权值是一个数字，它能代表两个顶点间的物理距离，或者从一个顶点到另一个顶点的时间，这种图被称为有权图；反之边没有赋值的则称为无权图。

### 图的表示

　　我们知道图是由顶点和边组成，那么在计算机中，怎么来模拟顶点和边？

#### 1) 顶点
　　在大多数情况下，顶点表示某个真实世界的对象，这个对象必须用数据项来描述。这里我们仅仅在顶点中存储了一个字母来标识顶点，同时还有一个标志位，用来判断该顶点有没有被访问过（用于后面的搜索）。
```java
public class Vertex {
    public char label;
    public boolean wasVisited;
     
    public Vertex(char label){
        this.label = label;
        wasVisited = false;
    }
}
```
　　顶点对象能放在数组中，然后用下标指示，也可以放在链表或其它数据结构中，不论使用什么结构，存储只是为了使用方便，这与边如何连接点是没有关系的。

#### 2) 边
　　在前面讲解各种树的数据结构时，大多数树都是每个节点包含它的子节点的引用，比如红黑树、二叉树。也有用数组表示树，树组中节点的位置决定了它和其它节点的关系，比如堆就是用数组表示。

　　然而图并不像树，图没有固定的结构，图的每个顶点可以与任意多个顶点相连，为了模拟这种自由形式的组织结构，用如下两种方式表示图：邻接矩阵和邻接表。

　　示例图：[graph_representation.png]

##### ① 邻接矩阵
　　邻接矩阵是一个二维数组，数据项表示两点间是否存在边，如果图中有 N 个顶点，邻接矩阵就是 N*N 的数组。

　　1表示有边，0表示没有边，也可以用布尔变量true和false来表示。顶点与自身相连用 0 表示，所以这个矩阵从左上角到右上角的对角线全是 0 。

　　注意：这个矩阵的上三角是下三角的镜像，两个三角包含了相同的信息，这个冗余信息看似低效，但是在大多数计算机中，创造一个三角形数组比较困难，所以只好接受这个冗余，
这也要求在程序处理中，比如当我们增加一条边时，要更新邻接矩阵的两部分，而不是一部分。

##### ② 邻接表
　　邻接表是一个链表数组（或者是链表的链表），每个单独的链表表示了有哪些顶点与当前顶点邻接。

### 搜索
　　在图中实现最基本的操作之一就是搜索从一个指定顶点可以到达哪些顶点，有两种方法可以用来搜索图：深度优先搜索（DFS）和广度优先搜索（BFS）。
它们最终都会到达所有连通的顶点，深度优先搜索通过【栈】来实现，而广度优先搜索通过【队列】来实现，不同的实现机制导致不同的搜索方式。

#### 1) 深度优先搜索（DFS,Depth-First Search ）


#### 2) 广度优先搜索（BFS,Breadth-First Search）